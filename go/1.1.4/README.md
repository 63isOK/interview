# 实现一个LRU算法

## plan

### 任务目标

1. 实现一个LRU算法
2. 用缓存数据结构来实现

### 任务分析

LRU是缓存置换算法中的一种，近期最少使用算法。
基于LRU算法的扩展有很多，本题实现一个最简单的LRU即可。

一个基本的LRU实现应该包含以下几点：

1. 缓存未满，不发生置换
2. 缓存满，命中，不发生置换
3. 缓存满，未命中，发生置换

LRU算法包含了请求缓存，到最后的置换操作并返回响应，
这里将读和置换分开处理(毕竟没有具体的应用场景)。

读get：读到了就返回值，未读到返回-1  
写put：命中就更新，未命中就置换

### 课题

实现一个简单的lru，支持get和put方法

### 课题的解决方案

- 实现LRU算法
- 使用go和tdd来实现(正好在熟悉这块)

## Do

### 确定行动措施

1. [ ] 以tdd的方式完成, 测试以功能测试为主
2. [ ] 可视化分析一下性能

```shell
# 用下面命令来生成性能分析文件
go test -bench="." -benchmem -cpuprofile profile.out

# 用下面的命令来在web生成可视化图
go tool pprof -http=172.17.0.2:8000 profile.out
```

## Check

- 都是利用go原生的包去实现的，包括单链表都是用list代替的
- 整个测试还可以更加简化:自己组装数据类型和接口
- 测试的结果看 "空间换时间" > "修改链表方向" > "递归"
- 分析：
  - 空间换时间：只遍历一次链表，值不是很大的情况下，最优;不然需要考虑空间
  - 修改链表方向：遍历两次，修改了原始数据结构，适用场景有限
  - 递归：主要是调用栈深度不确定，实际结果也是最差的
- 本次分析重构的非常少，印象因子非常多

## Adjust

- tdd测试使用了常用的手段：
  - 基本的测试
  - 辅助函数
  - 测试项集合
  - 基准测试
  - 性能分析
- 不足的地方是没有使用第三方生成可视化图表
- 另一个不足的地方是数据结构不是自定义的，而是使用go原生的
- 如果使用自定义数据结构，结果应该会更好一点

## 总结

2019.10.22

考虑到现在硬件比较充裕，可靠优先考虑使用空间换性能的方案，
只有在链表节点值非常大，而空间资源不足的情况下，可以考虑创建映射链表，
如果不关心原始数据结构，可以直接修改原始数据结构。

总之，除非链表非常短，不然不推荐使用递归的方式来解决。

## 附录

LRU：least recently used 近期最少使用算法，当缓存满时，淘汰掉近期最少使用的缓存。
详细信息可查看yb-post
