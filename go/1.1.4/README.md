# 实现一个LRU算法

## plan

### 任务目标

1. 实现一个LRU算法
2. 用缓存数据结构来实现

### 任务分析

LRU是缓存置换算法中的一种，近期最少使用算法。
基于LRU算法的扩展有很多，本题实现一个最简单的LRU即可。

一个基本的LRU实现应该包含以下几点：

1. 缓存未满，不发生置换
2. 缓存满，命中，不发生置换
3. 缓存满，未命中，发生置换

LRU算法包含了请求缓存，到最后的置换操作并返回响应，
这里将读和置换分开处理(毕竟没有具体的应用场景)。

读get：读到了就返回值，未读到返回-1  
写put：命中就更新，未命中就置换

### 课题

实现一个简单的lru，支持get和put方法

### 课题的解决方案

- 实现LRU算法
- 使用go和tdd来实现(正好在熟悉这块)

## Do

### 确定行动措施

1. [x] 以tdd的方式完成, 测试以功能测试为主

## Check

为了测试LRU算法的正确性，并没有比较不同LRU算法之间的性能，
数据结构选择都是比较简单的数组来代替缓存，只是实现了LRU而已。

## Adjust

本次tdd是完全不清楚如何实现的情况下先写了测试例子，
写完之后，就明白了LRU算法执行完之后的效果，并应该如何校验结果的正确性，
之后写实现的时候就发现特别简单,最主要是一次就做了正确的事，
如果换成非tdd写法，可能是 编码 - 构建验证测试例子 - 修改 - ...

总之tdd写测试例子时，不应该考虑如何实现，只需要考虑如何保证测试正确，
在实现时，只需要考虑最小实现，不需要扩展功能。

## 总结

2019.10.22

LRU,最近最少使用算法，是缓存置换算法中的一种，而且是比较简单的一种，
在没有具体场景的情况下，只测试了LRU的正确性，那就更加简单了一点。

其次，对tdd有了一些新的感受。而且tdd确实可以保证一次将事做正确。

## 附录

LRU：least recently used 近期最少使用算法，当缓存满时，淘汰掉近期最少使用的缓存。
详细信息可查看yb-post
